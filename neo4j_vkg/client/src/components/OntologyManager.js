import React, { useState, useEffect } from 'react';
import { useTenant } from '../contexts/TenantContext';
import { usePermissions } from '../hooks/usePermissions';
import './OntologyManager.css';

const API_BASE_URL = '/api';

/**
 * OntologyManager Component
 * View, edit, and manage predefined and custom ontologies
 */
const OntologyManager = ({ onClose, onSelectOntology }) => {
  const { currentWorkspace, getTenantHeaders } = useTenant();
  const { canManageOntology } = usePermissions();
  const [ontologies, setOntologies] = useState([]);
  const [selectedOntology, setSelectedOntology] = useState(null);
  const [loading, setLoading] = useState(true);
  const [editMode, setEditMode] = useState(false);
  const [editedOntology, setEditedOntology] = useState(null);
  const [saving, setSaving] = useState(false);
  const [newName, setNewName] = useState('');
  const [newDescription, setNewDescription] = useState('');

  // Fetch all ontologies on mount
  useEffect(() => {
    fetchOntologies();
  }, [currentWorkspace?.workspace_id]);

  const fetchOntologies = async () => {
    setLoading(true);
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      const params = new URLSearchParams({
        tenantId: currentWorkspace?.tenant_id || 'default',
        workspaceId: currentWorkspace?.workspace_id || 'default',
        scope: 'global' // Fetch only global ontologies
      });
      
      // Fetch from OWL API (GraphDB) - global ontologies only
      const response = await fetch(`${API_BASE_URL}/owl/list?${params}`, {
        signal: controller.signal,
        headers: getTenantHeaders()
      });
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // Transform OWL ontologies to match expected format
      const transformedOntologies = (data.ontologies || []).map(ont => ({
        id: ont.ontologyId || ont.iri,
        iri: ont.iri,
        name: ont.label || ont.iri.split(/[#/]/).pop(),
        label: ont.label,
        description: ont.comment,
        version: ont.versionInfo,
        ontologyId: ont.ontologyId,
        graphIRI: ont.graphIRI,
        scope: ont.scope || 'global', // Use scope from API
        isCustom: false, // OWL ontologies from GraphDB
        isAutoGenerated: false,
        entityTypes: [], // Will be loaded on demand
        relationships: []
      }));
      
      setOntologies(transformedOntologies);
    } catch (error) {
      console.error('Failed to fetch ontologies:', error);
      setOntologies([]);
    } finally {
      setLoading(false);
    }
  };

  const selectOntology = async (ont) => {
    setSelectedOntology(ont);
    setEditMode(false);
    setEditedOntology(null);
    
    // If it's a custom ontology, fetch full details
    if (ont.isCustom) {
      try {
        const response = await fetch(`${API_BASE_URL}/ontology/custom-ontology/${ont.id}`);
        const data = await response.json();
        if (data.ontology) {
          setSelectedOntology(data.ontology);
        }
      } catch (error) {
        console.error('Failed to fetch ontology details:', error);
      }
    }
  };

  const startEdit = () => {
    // entityTypes is the source of truth
    let entityTypes = selectedOntology.entityTypes || selectedOntology.originalEntityTypes || [];
    
    if (entityTypes.length === 0) {
      // Convert simple nodeTypes to rich format
      const simpleTypes = selectedOntology.nodeTypes || selectedOntology.conceptTypes || [];
      entityTypes = simpleTypes.map(t => ({
        label: t,
        userLabel: t,
        description: '',
        include: true
      }));
    }
    
    // relationships is the source of truth
    let relationships = selectedOntology.relationships || selectedOntology.originalRelationships || [];
    relationships = relationships.map(r => ({
      predicate: r.userPredicate || r.type || r.predicate,
      userPredicate: r.userPredicate || r.type || r.predicate,
      from: r.from || '',
      to: r.to || '',
      include: r.include !== false
    }));
    
    setEditedOntology({
      ...selectedOntology,
      entityTypes,
      relationships
    });
    setNewName(selectedOntology.isCustom ? selectedOntology.name : `${selectedOntology.name} (Custom)`);
    setNewDescription(selectedOntology.description || '');
    setEditMode(true);
  };

  const cancelEdit = () => {
    setEditMode(false);
    setEditedOntology(null);
  };

  const updateEntityType = (index, field, value) => {
    setEditedOntology(prev => {
      const updated = { ...prev };
      updated.entityTypes = [...prev.entityTypes];
      updated.entityTypes[index] = { ...updated.entityTypes[index], [field]: value };
      return updated;
    });
  };

  const removeEntityType = (index) => {
    setEditedOntology(prev => ({
      ...prev,
      entityTypes: prev.entityTypes.filter((_, i) => i !== index)
    }));
  };

  const addEntityType = () => {
    setEditedOntology(prev => ({
      ...prev,
      entityTypes: [...prev.entityTypes, { label: '', userLabel: '', description: '', include: true }]
    }));
  };

  const updateRelationship = (index, field, value) => {
    setEditedOntology(prev => {
      const updated = { ...prev };
      updated.relationships = [...prev.relationships];
      if (field === 'predicate') {
        updated.relationships[index] = { 
          ...updated.relationships[index], 
          predicate: value.toUpperCase().replace(/\s+/g, '_'),
          userPredicate: value.toUpperCase().replace(/\s+/g, '_')
        };
      } else {
        updated.relationships[index] = { ...updated.relationships[index], [field]: value };
      }
      return updated;
    });
  };

  const removeRelationship = (index) => {
    setEditedOntology(prev => ({
      ...prev,
      relationships: prev.relationships.filter((_, i) => i !== index)
    }));
  };

  const addRelationship = () => {
    setEditedOntology(prev => ({
      ...prev,
      relationships: [...prev.relationships, { predicate: '', userPredicate: '', from: '', to: '', include: true }]
    }));
  };

  const saveAsNew = async () => {
    if (!newName.trim()) {
      alert('Please enter a name for the ontology');
      return;
    }

    const validEntityTypes = editedOntology.entityTypes.filter(et => 
      (et.userLabel || et.label)?.trim()
    );

    if (validEntityTypes.length === 0) {
      alert('Please add at least one class');
      return;
    }

    setSaving(true);
    try {
      const response = await fetch(`${API_BASE_URL}/ontology/custom-ontology`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...getTenantHeaders() },
        body: JSON.stringify({
          name: newName.trim(),
          description: newDescription.trim(),
          workspace_id: currentWorkspace?.workspace_id || '',
          entityTypes: validEntityTypes.map(et => ({
            ...et,
            label: et.userLabel || et.label,
            include: true
          })),
          relationships: editedOntology.relationships.filter(r => 
            (r.userPredicate || r.predicate)?.trim()
          ).map(r => ({
            ...r,
            predicate: r.userPredicate || r.predicate,
            include: true
          })),
          sourceDocument: `Modified from: ${selectedOntology.name}`
        })
      });

      if (!response.ok) {
        let errorMessage = 'Failed to save ontology';
        try {
          const errorData = await response.json();
          errorMessage = errorData.message || errorData.error || errorMessage;
        } catch (e) {
          errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        }
        throw new Error(errorMessage);
      }

      const result = await response.json();
      alert(`‚úÖ Ontology "${newName}" saved successfully!`);
      
      // Refresh list and select new ontology
      await fetchOntologies();
      setEditMode(false);
      setEditedOntology(null);
      
      // Select the newly created ontology
      if (result.ontology) {
        setSelectedOntology(result.ontology);
      }
    } catch (error) {
      console.error('Save failed:', error);
      alert(`Error: ${error.message}`);
    } finally {
      setSaving(false);
    }
  };

  const updateExisting = async () => {
    if (!selectedOntology.isCustom) {
      // Can't update predefined, save as new instead
      await saveAsNew();
      return;
    }

    setSaving(true);
    try {
      const response = await fetch(`${API_BASE_URL}/ontology/custom-ontology/${selectedOntology.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', ...getTenantHeaders() },
        body: JSON.stringify({
          name: newName.trim(),
          description: newDescription.trim(),
          workspace_id: currentWorkspace?.workspace_id || '',
          entityTypes: editedOntology.entityTypes.filter(et => 
            (et.userLabel || et.label)?.trim()
          ),
          relationships: editedOntology.relationships.filter(r => 
            (r.userPredicate || r.predicate)?.trim()
          )
        })
      });

      if (!response.ok) throw new Error('Failed to update ontology');

      alert(`‚úÖ Ontology updated successfully!`);
      await fetchOntologies();
      setEditMode(false);
      setEditedOntology(null);
      
      // Refresh selected ontology
      await selectOntology({ ...selectedOntology, id: selectedOntology.id });
    } catch (error) {
      console.error('Update failed:', error);
      alert(`Error: ${error.message}`);
    } finally {
      setSaving(false);
    }
  };

  const deleteOntology = async () => {
    if (!selectedOntology.isCustom) {
      alert('Cannot delete predefined ontologies');
      return;
    }

    if (!window.confirm(`Delete "${selectedOntology.name}"? This cannot be undone.`)) {
      return;
    }

    try {
      const response = await fetch(`${API_BASE_URL}/ontology/custom-ontology/${selectedOntology.id}`, {
        method: 'DELETE'
      });

      if (!response.ok) throw new Error('Failed to delete ontology');

      alert('Ontology deleted');
      await fetchOntologies();
      setSelectedOntology(null);
    } catch (error) {
      console.error('Delete failed:', error);
      alert(`Error: ${error.message}`);
    }
  };

  const useOntology = () => {
    if (onSelectOntology && selectedOntology) {
      onSelectOntology(selectedOntology.id);
      onClose();
    }
  };

  // Get entity type labels for relationship dropdowns
  const getEntityLabels = () => {
    if (editMode && editedOntology) {
      return editedOntology.entityTypes
        .map(et => et.userLabel || et.label)
        .filter(Boolean);
    }
    return [];
  };

  return (
    <div className="ontology-manager-overlay">
      <div className="ontology-manager">
        <div className="om-header">
          <h2>üìö Ontology Manager</h2>
          <p>View, edit, and manage your ontologies</p>
          <button className="om-close-btn" onClick={onClose}>√ó</button>
        </div>

        <div className="om-content">
          {/* Ontology List */}
          <div className="om-sidebar">
            <h3>Available Ontologies</h3>
            {loading ? (
              <div className="om-loading">
                <div className="om-spinner"></div>
                <span>Loading ontologies...</span>
                <button className="om-retry-btn" onClick={fetchOntologies}>Retry</button>
              </div>
            ) : ontologies.length === 0 ? (
              <div className="om-loading">
                <span>No ontologies found</span>
                <button className="om-retry-btn" onClick={fetchOntologies}>Retry</button>
              </div>
            ) : (
              <div className="om-list">
                {ontologies.map(ont => (
                  <div 
                    key={ont.id}
                    className={`om-list-item ${selectedOntology?.id === ont.id ? 'selected' : ''} ${ont.isCustom ? 'custom' : ''} ${ont.isAutoGenerated ? 'auto' : ''}`}
                    onClick={() => selectOntology(ont)}
                  >
                    <span className="om-item-icon">
                      {ont.isAutoGenerated ? 'ü§ñ' : ont.isCustom ? 'üìå' : 'üè≠'}
                    </span>
                    <div className="om-item-info">
                      <span className="om-item-name">{ont.name}</span>
                      <span className="om-item-meta">
                        {ont.entityTypes?.length || 0} classes, {ont.relationships?.length || 0} relations
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Ontology Details */}
          <div className="om-details">
            {!selectedOntology ? (
              <div className="om-placeholder">
                <span className="placeholder-icon">üëà</span>
                <p>Select an ontology to view details</p>
              </div>
            ) : editMode ? (
              /* Edit Mode */
              <div className="om-edit-panel">
                <div className="om-edit-header">
                  <h3>‚úèÔ∏è {selectedOntology.isCustom ? 'Edit' : 'Customize'} Ontology</h3>
                  {!selectedOntology.isCustom && (
                    <p className="om-edit-notice">
                      Predefined ontologies cannot be modified directly. 
                      Your changes will be saved as a new custom ontology.
                    </p>
                  )}
                </div>

                <div className="om-edit-form">
                  <div className="om-form-group">
                    <label>Name</label>
                    <input
                      type="text"
                      value={newName}
                      onChange={(e) => setNewName(e.target.value)}
                      placeholder="Ontology name..."
                    />
                  </div>
                  <div className="om-form-group">
                    <label>Description</label>
                    <input
                      type="text"
                      value={newDescription}
                      onChange={(e) => setNewDescription(e.target.value)}
                      placeholder="Optional description..."
                    />
                  </div>

                  {/* Classes */}
                  <div className="om-section">
                    <div className="om-section-header">
                      <h4>üì¶ Classes</h4>
                      <button className="om-add-btn" onClick={addEntityType}>+ Add</button>
                    </div>
                    <div className="om-items-list">
                      {editedOntology?.entityTypes?.map((et, index) => (
                        <div key={index} className="om-edit-item">
                          <input
                            type="text"
                            value={et.userLabel || et.label || ''}
                            onChange={(e) => updateEntityType(index, 'userLabel', e.target.value)}
                            placeholder="Class name..."
                            className="om-input-main"
                          />
                          <input
                            type="text"
                            value={et.description || ''}
                            onChange={(e) => updateEntityType(index, 'description', e.target.value)}
                            placeholder="Description..."
                            className="om-input-desc"
                          />
                          <button 
                            className="om-remove-btn" 
                            onClick={() => removeEntityType(index)}
                            title="Remove"
                          >
                            √ó
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Relationships */}
                  <div className="om-section">
                    <div className="om-section-header">
                      <h4>üîó Relationships</h4>
                      <button className="om-add-btn" onClick={addRelationship}>+ Add</button>
                    </div>
                    <div className="om-items-list">
                      {editedOntology?.relationships?.map((rel, index) => (
                        <div key={index} className="om-edit-item relationship">
                          <select
                            value={rel.from || ''}
                            onChange={(e) => updateRelationship(index, 'from', e.target.value)}
                            className="om-select-from"
                          >
                            <option value="">From...</option>
                            {getEntityLabels().map(label => (
                              <option key={label} value={label}>{label}</option>
                            ))}
                          </select>
                          <input
                            type="text"
                            value={rel.userPredicate || rel.predicate || ''}
                            onChange={(e) => updateRelationship(index, 'predicate', e.target.value)}
                            placeholder="RELATIONSHIP_TYPE"
                            className="om-input-predicate"
                          />
                          <select
                            value={rel.to || ''}
                            onChange={(e) => updateRelationship(index, 'to', e.target.value)}
                            className="om-select-to"
                          >
                            <option value="">To...</option>
                            {getEntityLabels().map(label => (
                              <option key={label} value={label}>{label}</option>
                            ))}
                          </select>
                          <button 
                            className="om-remove-btn" 
                            onClick={() => removeRelationship(index)}
                            title="Remove"
                          >
                            √ó
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <div className="om-edit-actions">
                  <button className="btn btn-cancel" onClick={cancelEdit} disabled={saving}>
                    Cancel
                  </button>
                  {selectedOntology.isCustom && (
                    <button className="btn btn-update" onClick={updateExisting} disabled={saving}>
                      {saving ? '‚è≥ Saving...' : 'üíæ Update'}
                    </button>
                  )}
                  <button className="btn btn-save" onClick={saveAsNew} disabled={saving}>
                    {saving ? '‚è≥ Saving...' : '‚ú® Save as New'}
                  </button>
                </div>
              </div>
            ) : (
              /* View Mode */
              <div className="om-view-panel">
                <div className="om-view-header">
                  <div className="om-view-title">
                    <span className="om-view-icon">
                      {selectedOntology.isAutoGenerated ? 'ü§ñ' : selectedOntology.isCustom ? 'üìå' : 'üè≠'}
                    </span>
                    <h3>{selectedOntology.name}</h3>
                  </div>
                  {selectedOntology.description && (
                    <p className="om-view-desc">{selectedOntology.description}</p>
                  )}
                  <div className="om-view-badges">
                    {selectedOntology.isAutoGenerated && (
                      <span className="badge auto">Auto-Generated</span>
                    )}
                    {selectedOntology.isCustom && (
                      <span className="badge custom">Custom</span>
                    )}
                    {!selectedOntology.isAutoGenerated && !selectedOntology.isCustom && (
                      <span className="badge predefined">Predefined</span>
                    )}
                  </div>
                </div>

                {selectedOntology.isAutoGenerated ? (
                  <div className="om-auto-notice">
                    <span className="notice-icon">‚ÑπÔ∏è</span>
                    <p>This mode lets the LLM automatically detect classes and relationships from your document. No predefined schema constraints.</p>
                  </div>
                ) : (
                  <>
                    {/* Classes */}
                    <div className="om-section">
                      <h4>üì¶ Classes ({selectedOntology.entityTypes?.length || 0})</h4>
                      <div className="om-tags">
                        {(selectedOntology.entityTypes || []).map((et, i) => (
                          <span key={i} className="om-tag entity">{et.userLabel || et.label}</span>
                        ))}
                        {(selectedOntology.entityTypes?.length || 0) === 0 && (
                          <span className="om-empty">No classes defined</span>
                        )}
                      </div>
                    </div>

                    {/* Relationships */}
                    <div className="om-section">
                      <h4>üîó Relationships ({selectedOntology.relationships?.length || 0})</h4>
                      <div className="om-relationships">
                        {(selectedOntology.relationships || []).map((rel, i) => (
                          <div key={i} className="om-rel-item">
                            <span className="rel-from">{rel.from || '?'}</span>
                            <span className="rel-arrow">‚Üí</span>
                            <span className="rel-predicate">{rel.type || rel.predicate}</span>
                            <span className="rel-arrow">‚Üí</span>
                            <span className="rel-to">{rel.to || '?'}</span>
                          </div>
                        ))}
                        {(selectedOntology.predicates && !selectedOntology.relationships?.length) && (
                          <div className="om-tags">
                            {selectedOntology.predicates.map((pred, i) => (
                              <span key={i} className="om-tag relation">{pred}</span>
                            ))}
                          </div>
                        )}
                        {(selectedOntology.relationships?.length || selectedOntology.predicates?.length || 0) === 0 && (
                          <span className="om-empty">No relationships defined</span>
                        )}
                      </div>
                    </div>
                  </>
                )}

                <div className="om-view-actions">
                  {!selectedOntology.isAutoGenerated && canManageOntology && (
                    <button className="btn btn-edit" onClick={startEdit}>
                      ‚úèÔ∏è {selectedOntology.isCustom ? 'Edit' : 'Customize'}
                    </button>
                  )}
                  {selectedOntology.isCustom && canManageOntology && (
                    <button className="btn btn-delete" onClick={deleteOntology}>
                      üóëÔ∏è Delete
                    </button>
                  )}
                  <button className="btn btn-use" onClick={useOntology}>
                    ‚úÖ Use This Ontology
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default OntologyManager;

